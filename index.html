<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Feliz aniversário, Karols!</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <canvas id="canvas" aria-label="Coração animado com texto 'Feliz aniversário, Karols!'"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resize, { passive: true });
    resize();

    // Texto que vai formar o contorno
    const text = 'Feliz aniversário, Karols! ';
    // quantidade de pontos ao longo do contorno (aumente para mais densidade)
    const POINTS = 200;
    const pts = [];

    // função matemática do coração (param t de 0 a 2π)
    function heart(t) {
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
      return [x, y];
    }

    // geramos os pontos normalizados uma vez (serão escalados depois)
    function generatePoints() {
      pts.length = 0;
      for (let i = 0; i < POINTS; i++) {
        const t = (i / POINTS) * Math.PI * 2;
        const [x, y] = heart(t);
        pts.push({ x, y, t });
      }
    }
    generatePoints();

    // animação
    let last = 0;
    function draw(now) {
      const w = window.innerWidth;
      const h = window.innerHeight;
      // background
      ctx.clearRect(0, 0, w, h);
      // escala do coração dependendo da tela (usa min)
      const scale = Math.min(w, h) / 50; // ajuste para tamanho
      const cx = w / 2;
      const cy = h / 2.2; // ligeiro deslocamento pra cima

      // animação de pulso/rotação suave
      const time = now / 1000;
      const rotate = Math.sin(time * 0.7) * 0.08; // rotação sutil
      const offsetRadius = Math.sin(time * 1.2) * 3; // leve pulso

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(rotate);

      // desenho do texto em cada ponto
      for (let i = 0; i < pts.length; i++) {
        const p = pts[i];
        // posição base
        const px = p.x * scale;
        const py = p.y * scale;

        // ligeiro deslocamento radial para dar movimento
        const nx = px + (p.x / Math.hypot(p.x, p.y)) * offsetRadius;
        const ny = py + (p.y / Math.hypot(p.x, p.y)) * offsetRadius;

        // ângulo de rotação do texto na borda
        const angle = Math.atan2(ny, nx) + Math.PI / 2 + Math.sin(time + i * 0.02) * 0.15;

        ctx.save();
        ctx.translate(nx, ny);

        // rotaciona o texto para seguir a curva
        ctx.rotate(angle);

        // escolha de cor, sombra e tamanho responsivo
        const fontSize = Math.max(10, Math.min(20, Math.floor(Math.min(w, h) * 0.018)));
        ctx.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial`;
        ctx.fillStyle = '#ff98c2';
        ctx.textBaseline = 'middle';

        // brilho externo: sombra suave
        ctx.shadowColor = 'rgba(255,200,240,0.9)';
        ctx.shadowBlur = 8;

        // pick the character to draw
        const ch = text[i % text.length];
        ctx.fillText(ch, 0, 0);

        ctx.restore();
      }

      ctx.restore();

      // small inner dark circle to create hollow center like the reference
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      ctx.beginPath();
      const innerR = Math.min(w, h) * 0.14; // ajusta aqui o tamanho do "buraco"
      ctx.arc(cx, cy, innerR, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // optional soft glow ring: draw translucent ring on top
      ctx.save();
      ctx.beginPath();
      ctx.arc(cx, cy, innerR + 2, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255,150,200,0.06)';
      ctx.lineWidth = Math.min(w, h) * 0.02;
      ctx.stroke();
      ctx.restore();

      requestAnimationFrame(draw);
    }

    requestAnimationFrame(draw);
  </script>
</body>
</html>
